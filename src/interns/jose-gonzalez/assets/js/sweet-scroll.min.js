/*!
 * sweet-scroll
 * Modern and the sweet smooth scroll library.
 * @author tsuyoshiwada
 * @license MIT
 * @version 2.2.0
 */
!(function (t, n) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = n() : typeof define === 'function' && define.amd ? define(n) : t.SweetScroll = n() }(this, function () { 'use strict'; function t (t) { return t == null ? '' : (typeof t === 'undefined' ? 'undefined' : St(t)) === 'object' || typeof t === 'function' ? wt[Object.prototype.toString.call(t)] || 'object' : typeof t === 'undefined' ? 'undefined' : St(t) } function n (n) { return t(n) === 'number' } function e (n) { return t(n) === 'string' } function i (n) { return t(n) === 'function' } function o (t) { return Array.isArray(t) } function r (t) { const e = t == null ? null : t.length; return n(e) && e >= 0 && e <= bt } function l (t) { return !o(t) && t - parseFloat(t) + 1 >= 0 } function u (n) { return !o(n) && t(n) === 'object' } function a (t, n) { return t && t.hasOwnProperty(n) } function s (t, n, e) { if (t == null) return t; const i = e || t; if (u(t)) { for (const o in t) if (a(t, o) && n.call(i, t[o], o) === !1) break } else if (r(t)) for (let l = 0; l < t.length && n.call(i, t[l], l) !== !1; l++);return t } function c (t) { for (var n = arguments.length, e = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)e[i - 1] = arguments[i]; return s(e, function (n) { s(n, function (n, e) { t[e] = n }) }), t } function h (t) { return t.replace(/\s*/g, '') || '' } function f (t) { typeof console !== 'undefined' && typeof console.error === 'function' && console.error(t); try { throw new Error(t) } catch (t) {} } function p (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (t) return (n == null ? xt : n).querySelector(t) } function d (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (t) return (n == null ? xt : n).querySelectorAll(t) } function v (t, n) { for (var e = (t.document || t.ownerDocument).querySelectorAll(n), i = e.length; --i >= 0 && e.item(i) !== t;);return i > -1 } function g (t) { return t === xt.documentElement || t === xt.body } function y () { const t = _t.outerWidth; const n = _t.innerWidth; return t ? t / n : 1 } function S (t) { for (var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'y', e = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i = Lt[n], o = t instanceof Element ? [t] : d(t), r = [], l = xt.createElement('div'), u = 0; u < o.length; u++) { const a = o[u]; if (a[i] > 0 ? r.push(a) : (l.style.width = a.clientWidth + 1 + 'px', l.style.height = a.clientHeight + 1 + 'px', a.appendChild(l), a[i] = 1.5 / y(), a[i] > 0 && r.push(a), a[i] = 0, a.removeChild(l)), !e && r.length > 0) break } return r } function m (t, n) { const e = S(t, n, !1); return e.length >= 1 ? e[0] : null } function k (t) { return t != null && t === t.window ? t : t.nodeType === 9 && t.defaultView } function b (t) { return vt(t.scrollHeight, t.clientHeight, t.offsetHeight) } function C (t) { return vt(t.scrollWidth, t.clientWidth, t.offsetWidth) } function w (t) { return { width: C(t), height: b(t) } } function O () { return { width: vt(C(xt.body), C(xt.documentElement)), height: vt(b(xt.body), b(xt.documentElement)) } } function I (t) { return g(t) ? { viewport: { width: gt(_t.innerWidth, xt.documentElement.clientWidth), height: _t.innerHeight }, size: O() } : { viewport: { width: t.clientWidth, height: t.clientHeight }, size: w(t) } } function _ (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'y'; const e = k(t); return e ? e[Et[n]] : t[Lt[n]] } function x (t, n) { const e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'y'; const i = k(t); const o = e === 'y'; i ? i.scrollTo(o ? i[Et.x] : n, o ? n : i[Et.y]) : t[Lt[e]] = n } function L (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (!t || t && !t.getClientRects().length) return { top: 0, left: 0 }; const e = t.getBoundingClientRect(); if (e.width || e.height) { const i = {}; let o = null; if (n == null || g(n))o = t.ownerDocument.documentElement, i.top = _t.pageYOffset, i.left = _t.pageXOffset; else { o = n; const r = o.getBoundingClientRect(); i.top = r.top * -1 + o.scrollTop, i.left = r.left * -1 + o.scrollLeft } return { top: e.top + i.top - o.clientTop, left: e.left + i.left - o.clientLeft } } return e } function E (t, n, e) { const i = n.split(','); i.forEach(function (n) { t.addEventListener(n.trim(), e, !1) }) } function A (t, n, e) { const i = n.split(','); i.forEach(function (n) { t.removeEventListener(n.trim(), e, !1) }) } function M (t) { return t } function R (t, n, e, i, o) { return i * (n /= o) * n + e } function T (t, n, e, i, o) { return -i * (n /= o) * (n - 2) + e } function z (t, n, e, i, o) { return (n /= o / 2) < 1 ? i / 2 * n * n + e : -i / 2 * (--n * (n - 2) - 1) + e } function q (t, n, e, i, o) { return i * (n /= o) * n * n + e } function D (t, n, e, i, o) { return i * ((n = n / o - 1) * n * n + 1) + e } function P (t, n, e, i, o) { return (n /= o / 2) < 1 ? i / 2 * n * n * n + e : i / 2 * ((n -= 2) * n * n + 2) + e } function Q (t, n, e, i, o) { return i * (n /= o) * n * n * n + e } function W (t, n, e, i, o) { return -i * ((n = n / o - 1) * n * n * n - 1) + e } function j (t, n, e, i, o) { return (n /= o / 2) < 1 ? i / 2 * n * n * n * n + e : -i / 2 * ((n -= 2) * n * n * n - 2) + e } function B (t, n, e, i, o) { return i * (n /= o) * n * n * n * n + e } function H (t, n, e, i, o) { return i * ((n = n / o - 1) * n * n * n * n + 1) + e } function N (t, n, e, i, o) { return (n /= o / 2) < 1 ? i / 2 * n * n * n * n * n + e : i / 2 * ((n -= 2) * n * n * n * n + 2) + e } function F (t, n, e, i, o) { return -i * at(n / o * (dt / 2)) + i + e } function U (t, n, e, i, o) { return i * st(n / o * (dt / 2)) + e } function $ (t, n, e, i, o) { return -i / 2 * (at(dt * n / o) - 1) + e } function X (t, n, e, i, o) { return n === 0 ? e : i * ct(2, 10 * (n / o - 1)) + e } function Y (t, n, e, i, o) { return n === o ? e + i : i * (-ct(2, -10 * n / o) + 1) + e } function J (t, n, e, i, o) { return n === 0 ? e : n === o ? e + i : (n /= o / 2) < 1 ? i / 2 * ct(2, 10 * (n - 1)) + e : i / 2 * (-ct(2, -10 * --n) + 2) + e } function V (t, n, e, i, o) { return -i * (ft(1 - (n /= o) * n) - 1) + e } function G (t, n, e, i, o) { return i * ft(1 - (n = n / o - 1) * n) + e } function K (t, n, e, i, o) { return (n /= o / 2) < 1 ? -i / 2 * (ft(1 - n * n) - 1) + e : i / 2 * (ft(1 - (n -= 2) * n) + 1) + e } function Z (t, n, e, i, o) { let r = 1.70158; let l = 0; let u = i; return n === 0 ? e : (n /= o) === 1 ? e + i : (l || (l = 0.3 * o), u < ht(i) ? (u = i, r = l / 4) : r = l / (2 * dt) * pt(i / u), -(u * ct(2, 10 * (n -= 1)) * st((n * o - r) * (2 * dt) / l)) + e) } function tt (t, n, e, i, o) { let r = 1.70158; let l = 0; let u = i; return n === 0 ? e : (n /= o) === 1 ? e + i : (l || (l = 0.3 * o), u < ht(i) ? (u = i, r = l / 4) : r = l / (2 * dt) * pt(i / u), u * ct(2, -10 * n) * st((n * o - r) * (2 * dt) / l) + i + e) } function nt (t, n, e, i, o) { let r = 1.70158; let l = 0; let u = i; return n === 0 ? e : (n /= o / 2) === 2 ? e + i : (l || (l = o * (0.3 * 1.5)), u < ht(i) ? (u = i, r = l / 4) : r = l / (2 * dt) * pt(i / u), n < 1 ? -0.5 * (u * ct(2, 10 * (n -= 1)) * st((n * o - r) * (2 * dt) / l)) + e : u * ct(2, -10 * (n -= 1)) * st((n * o - r) * (2 * dt) / l) * 0.5 + i + e) } function et (t, n, e, i, o) { const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1.70158; return i * (n /= o) * n * ((r + 1) * n - r) + e } function it (t, n, e, i, o) { const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1.70158; return i * ((n = n / o - 1) * n * ((r + 1) * n + r) + 1) + e } function ot (t, n, e, i, o) { let r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1.70158; return (n /= o / 2) < 1 ? i / 2 * (n * n * (((r *= 1.525) + 1) * n - r)) + e : i / 2 * ((n -= 2) * n * (((r *= 1.525) + 1) * n + r) + 2) + e } function rt (t, n, e, i, o) { return (n /= o) < 1 / 2.75 ? i * (7.5625 * n * n) + e : n < 2 / 2.75 ? i * (7.5625 * (n -= 1.5 / 2.75) * n + 0.75) + e : n < 2.5 / 2.75 ? i * (7.5625 * (n -= 2.25 / 2.75) * n + 0.9375) + e : i * (7.5625 * (n -= 2.625 / 2.75) * n + 0.984375) + e } function lt (t, n, e, i, o) { return i - rt(t, o - n, 0, i, o) + e } function ut (t, n, e, i, o) { return n < o / 2 ? 0.5 * lt(t, 2 * n, 0, i, o) + e : 0.5 * rt(t, 2 * n - o, 0, i, o) + 0.5 * i + e } var at = Math.cos; var st = Math.sin; var ct = Math.pow; var ht = Math.abs; var ft = Math.sqrt; var pt = Math.asin; var dt = Math.PI; var vt = Math.max; var gt = Math.min; const yt = Math.round; var St = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t }; const mt = function (t, n) { if (!(t instanceof n)) throw new TypeError('Cannot call a class as a function') }; const kt = (function () { function t (t, n) { for (let e = 0; e < n.length; e++) { const i = n[e]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (n, e, i) { return e && t(n.prototype, e), i && t(n, i), n } }()); var bt = ct(2, 53) - 1; const Ct = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Object']; var wt = {}; Ct.forEach(function (t) { wt['[object ' + t + ']'] = t.toLowerCase() }); const Ot = !(typeof window === 'undefined' || !window.document || !window.document.createElement); const It = (function () { if (!Ot) return !1; const t = navigator.userAgent; return (t.indexOf('Android 2.') === -1 && t.indexOf('Android 4.0') === -1 || t.indexOf('Mobile Safari') === -1 || t.indexOf('Chrome') !== -1 || t.indexOf('Windows Phone') !== -1) && (window.history && 'pushState' in window.history && window.location.protocol !== 'file:') }()); var _t = Ot ? window : null; var xt = Ot ? document : null; var Lt = { y: 'scrollTop', x: 'scrollLeft' }; var Et = { y: 'pageYOffset', x: 'pageXOffset' }; const At = Object.freeze({ linear: M, InQuad: R, OutQuad: T, InOutQuad: z, InCubic: q, OutCubic: D, InOutCubic: P, InQuart: Q, OutQuart: W, InOutQuart: j, InQuint: B, OutQuint: H, InOutQuint: N, InSine: F, OutSine: U, InOutSine: $, InExpo: X, OutExpo: Y, InOutExpo: J, InCirc: V, OutCirc: G, InOutCirc: K, InElastic: Z, OutElastic: tt, InOutElastic: nt, InBack: et, OutBack: it, InOutBack: ot, OutBounce: rt, InBounce: lt, InOutBounce: ut }); const Mt = ['ms', 'moz', 'webkit']; let Rt = 0; let Tt = Ot ? _t.requestAnimationFrame : null; let zt = Ot ? _t.cancelAnimationFrame : null; if (Ot) { for (let qt = 0; qt < Mt.length && !Tt; ++qt)Tt = _t[Mt[qt] + 'RequestAnimationFrame'], zt = _t[Mt[qt] + 'CancelAnimationFrame'] || _t[Mt[qt] + 'CancelRequestAnimationFrame']; Tt || (Tt = function (t) { const n = Date.now(); const e = vt(0, 16 - (n - Rt)); const i = setTimeout(function () { t(n + e) }, e); return Rt = n + e, i }), zt || (zt = function (t) { clearTimeout(t) }) } const Dt = (function () { function t (n) { mt(this, t), this.el = n, this.props = {}, this.options = {}, this.progress = !1, this.easing = null, this.startTime = null, this.rafId = null } return kt(t, [{ key: 'run', value: function (t, n, e) { const o = this; this.progress || (this.props = { x: t, y: n }, this.options = e, this.easing = i(e.easing) ? e.easing : At[e.easing.replace('ease', '')], this.progress = !0, setTimeout(function () { o.startProps = o.calcStartProps(t, n), o.rafId = Tt(function (t) { return o._loop(t) }) }, this.options.delay)) } }, { key: 'stop', value: function () { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const n = this.options.complete; this.startTime = null, this.progress = !1, zt(this.rafId), t && (x(this.el, this.props.x, 'x'), x(this.el, this.props.y, 'y')), i(n) && (n.call(this), this.options.complete = null) } }, { key: '_loop', value: function (t) { const n = this; if (this.startTime || (this.startTime = t), !this.progress) return void this.stop(!1); const e = this.el; const i = this.props; const o = this.options; const r = this.startTime; const l = this.startProps; const u = this.easing; const a = o.duration; const c = o.step; const h = {}; const f = t - r; const p = gt(1, vt(f / a, 0)); s(i, function (t, n) { const e = l[n]; const i = t - e; if (i === 0) return !0; const o = u(p, a * p, 0, 1, a); h[n] = yt(e + i * o) }), s(h, function (t, n) { x(e, t, n) }), f <= a ? (c.call(this, p, h), this.rafId = Tt(function (t) { return n._loop(t) })) : this.stop(!0) } }, { key: 'calcStartProps', value: function (t, n) { const e = { x: _(this.el, 'x'), y: _(this.el, 'y') }; if (this.options.quickMode) { const i = I(this.el); const o = i.viewport; const r = o.width; const l = o.height; ht(e.y - n) > l && (e.y = e.y > n ? n + l : n - l), ht(e.x - t) > r && (e.x = e.x > t ? t + r : t - r) } return e } }]), t }()); const Pt = (function () { return Ot ? 'onwheel' in xt ? 'wheel' : 'onmousewheel' in xt ? 'mousewheel' : 'DOMMouseScroll' : 'wheel' }()); const Qt = Pt + ', touchstart, touchmove'; const Wt = (function () { function t () { const n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'body, html'; mt(this, t), this.isSSR = !Ot, this.options = c({}, t.defaults, n), this.container = this.getContainer(e), this.container == null ? (this.header = null, this.tween = null, this.isSSR || (/comp|inter|loaded/.test(xt.readyState) ? this.log('Not found scrollable container. => "' + e + '"') : this.log('Should be initialize later than DOMContentLoaded.'))) : (this.header = p(this.options.header), this.tween = new Dt(this.container), this._trigger = null, this._shouldCallCancelScroll = !1, this.bindContainerClick()) } return kt(t, [{ key: 'log', value: function (t) { this.options.outputLog && f('[SweetScroll] ' + t) } }, { key: 'getScrollOffset', value: function (t, n) { const i = this.container; const o = this.header; const r = this.parseCoodinate(n.offset); let l = this.parseCoodinate(t); if (!l && e(t)) if (t === '#')l = { top: 0, left: 0 }; else { const u = p(t); const a = L(u, i); if (!a) return; l = a } return l ? (r && (l.top += r.top, l.left += r.left), o && (l.top = vt(0, l.top - w(o).height)), l) : null } }, { key: 'normalizeScrollOffset', value: function (t, n) { const e = this.container; const i = c({}, t); const o = I(e); const r = o.viewport; const l = o.size; return i.top = n.verticalScroll ? vt(0, gt(l.height - r.height, i.top)) : _(e, 'y'), i.left = n.horizontalScroll ? vt(0, gt(l.width - r.width, i.left)) : _(e, 'x'), i } }, { key: 'to', value: function (t) { const n = this; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.isSSR) { const o = this.container; const r = c({}, this.options, i); const l = this._trigger; const u = e(t) && /^#/.test(t) ? t : null; if (this._options = r, this._trigger = null, this._shouldCallCancelScroll = !1, this.stop(), !o) return this.log('Not found container element.'); let a = this.getScrollOffset(t, r); if (!a) return this.log('Invalid parameter of distance. => ' + t); if (this.hook(r, 'beforeScroll', a, l) === !1) return void (this._options = null); a = this.normalizeScrollOffset(a, r), this.tween.run(a.left, a.top, { duration: r.duration, delay: r.delay, easing: r.easing, quickMode: r.quickMode, complete: function () { u != null && u !== _t.location.hash && n.updateURLHash(u, r.updateURL), n.unbindContainerStop(), n._options = null, n._shouldCallCancelScroll ? n.hook(r, 'cancelScroll') : n.hook(r, 'afterScroll', a, l), n.hook(r, 'completeScroll', n._shouldCallCancelScroll) }, step: function (t, e) { n.hook(r, 'stepScroll', t, e) } }), this.bindContainerStop() } } }, { key: 'toTop', value: function (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.to(t, c({}, n, { verticalScroll: !0, horizontalScroll: !1 })) } }, { key: 'toLeft', value: function (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.to(t, c({}, n, { verticalScroll: !1, horizontalScroll: !0 })) } }, { key: 'toElement', value: function (t) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.isSSR) if (t instanceof Element) { const e = L(t, this.container); this.to(e, c({}, n)) } else this.log('Invalid parameter.') } }, { key: 'stop', value: function () { const t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.isSSR || (this.container ? (this._stopScrollListener && (this._shouldCallCancelScroll = !0), this.tween.stop(t)) : this.log('Not found scrollable container.')) } }, { key: 'update', value: function () { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.container ? (this.stop(), this.unbindContainerClick(), this.unbindContainerStop(), this.options = c({}, this.options, t), this.header = p(this.options.header), this.bindContainerClick()) : this.isSSR || this.log('Not found scrollable container.') } }, { key: 'destroy', value: function () { this.container ? (this.stop(), this.unbindContainerClick(), this.unbindContainerStop(), this.container = null, this.header = null, this.tween = null) : this.isSSR || this.log('Not found scrollable container.') } }, { key: 'beforeScroll', value: function (t, n) { return !0 } }, { key: 'cancelScroll', value: function () {} }, { key: 'afterScroll', value: function (t, n) {} }, { key: 'completeScroll', value: function (t) {} }, { key: 'stepScroll', value: function (t, n) {} }, { key: 'parseCoodinate', value: function (t) { const n = this._options ? this._options.verticalScroll : this.options.verticalScroll; let i = { top: 0, left: 0 }; if (a(t, 'top') || a(t, 'left'))i = c(i, t); else if (o(t))t.length === 2 ? (i.top = t[0], i.left = t[1]) : (i.top = n ? t[0] : 0, i.left = n ? 0 : t[0]); else if (l(t))i.top = n ? t : 0, i.left = n ? 0 : t; else { if (!e(t)) return null; let r = h(t); if (/^\d+,\d+$/.test(r))r = r.split(','), i.top = r[0], i.left = r[1]; else if (/^(top|left):\d+,?(?:(top|left):\d+)?$/.test(r)) { const u = r.match(/top:(\d+)/); const s = r.match(/left:(\d+)/); i.top = u ? u[1] : 0, i.left = s ? s[1] : 0 } else { if (!this.container || !/^(\+|-)=(\d+)$/.test(r)) return null; const f = _(this.container, n ? 'y' : 'x'); const p = r.match(/^(\+|-)=(\d+)$/); const d = p[1]; const v = parseInt(p[2], 10); d === '+' ? (i.top = n ? f + v : 0, i.left = n ? 0 : f + v) : (i.top = n ? f - v : 0, i.left = n ? 0 : f - v) } } return i.top = parseInt(i.top, 10), i.left = parseInt(i.left, 10), i } }, { key: 'updateURLHash', value: function (t, n) { !this.isSSR && It && n && _t.history[n === 'replace' ? 'replaceState' : 'pushState'](null, null, t) } }, { key: 'getContainer', value: function (t) { const n = this.options; const e = n.verticalScroll; const i = n.horizontalScroll; let o = null; return this.isSSR ? o : (e && (o = m(t, 'y')), !o && i && (o = m(t, 'x')), o) } }, { key: 'bindContainerClick', value: function () { const t = this.container; t && (this._containerClickListener = this.handleContainerClick.bind(this), E(t, 'click', this._containerClickListener)) } }, { key: 'unbindContainerClick', value: function () { const t = this.container; t && this._containerClickListener && (A(t, 'click', this._containerClickListener), this._containerClickListener = null) } }, { key: 'bindContainerStop', value: function () { const t = this.container; t && (this._stopScrollListener = this.handleStopScroll.bind(this), E(t, Qt, this._stopScrollListener)) } }, { key: 'unbindContainerStop', value: function () { const t = this.container; t && this._stopScrollListener && (A(t, Qt, this._stopScrollListener), this._stopScrollListener = null) } }, { key: 'hook', value: function (t, n) { for (var e = t[n], o = arguments.length, r = Array(o > 2 ? o - 2 : 0), l = 2; l < o; l++)r[l - 2] = arguments[l]; if (i(e)) { const u = e.apply(this, r); if (typeof u === 'undefined') return u } return this[n].apply(this, r) } }, { key: 'handleStopScroll', value: function (t) { const n = this._options ? this._options.stopScroll : this.options.stopScroll; n ? this.stop() : t.preventDefault() } }, { key: 'handleContainerClick', value: function (t) { for (let n = this.options, e = t.target; e && e !== xt; e = e.parentNode) if (v(e, n.trigger)) { const i = e.getAttribute('data-scroll'); const o = this.parseDataOptions(e); const r = i || e.getAttribute('href'); n = c({}, n, o), n.preventDefault && t.preventDefault(), n.stopPropagation && t.stopPropagation(), this._trigger = e, n.horizontalScroll && n.verticalScroll ? this.to(r, n) : n.verticalScroll ? this.toTop(r, n) : n.horizontalScroll && this.toLeft(r, n) } } }, { key: 'parseDataOptions', value: function (t) { const n = t.getAttribute('data-scroll-options'); return n ? JSON.parse(n) : {} } }]), t }()); return Wt.defaults = { trigger: '[data-scroll]', header: '[data-scroll-header]', duration: 1e3, delay: 0, easing: 'easeOutQuint', offset: 0, verticalScroll: !0, horizontalScroll: !1, stopScroll: !0, updateURL: !1, preventDefault: !0, stopPropagation: !0, outputLog: !1, quickMode: !1, beforeScroll: null, afterScroll: null, cancelScroll: null, completeScroll: null, stepScroll: null }, Wt }))
